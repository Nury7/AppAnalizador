fun syntaxAnalyze(tokens: List<Token>): List<String> {
    val errors = mutableListOf<String>()
    val iterator = tokens.iterator()
    var currentToken = iterator.next()

    fun expect(vararg expectedTypes: TokenType) {
        if (iterator.hasNext()) {
            if (currentToken.type !in expectedTypes) {
                val expectedTokens = expectedTypes.joinToString(", ") { it.pattern }
                errors.add("Error: Expected one of the tokens '$expectedTokens', found '${currentToken.value}'")
            }
            currentToken = iterator.next()
        } else {
            if (currentToken.type != TokenType.END) {
                val expectedTokens = expectedTypes.joinToString(", ") { it.pattern }
                errors.add("Error: Unexpected end of input, expected one of the tokens '$expectedTokens'")
            }
            }

    }

    fun parseINICIO() {
        expect(TokenType.START)
        expect(TokenType.OPEN_CURLY_BRACE)
    }

    fun parseFIN(){
        expect(TokenType.CLOSE_CURLY_BRACE)
        expect(TokenType.END)
    }

    fun parseVALOROPERACION() {
        currentToken = iterator.next()
        when (currentToken.type) {
            TokenType.IDENTIFIER, TokenType.INTEGER, TokenType.FLOAT -> { }
            TokenType.OP_SUM, TokenType.OP_RES, TokenType.OP_MUL, TokenType.OP_DIV -> { }
            else -> {
                errors.add("Error: Unexpected token '${currentToken.value}' in operation")
            }
        }
    }

    fun parseVALORES() {
        parseVALOROPERACION()
        while (iterator.hasNext() && iterator.next().type == TokenType.COMA) {
            parseVALOROPERACION()
        }
    }

    fun parseOPERACION() {
        if (currentToken.type in listOf(TokenType.OP_SUM, TokenType.OP_RES, TokenType.OP_MUL, TokenType.OP_DIV)) {
            if (iterator.hasNext() && iterator.next().type == TokenType.OPEN_PARENTHESES) {
                parseVALORES()
                if (iterator.hasNext() && iterator.next().type == TokenType.CLOSE_PARENTHESES) {
                    return
                }
            }
        }
    }

    fun parseVALORDECLARACION() {
        while (iterator.hasNext()) {
            currentToken = iterator.next()
            when (currentToken.type) {
                TokenType.IDENTIFIER -> {
                    expect(TokenType.IDENTIFIER)
                    if (iterator.hasNext() && iterator.next().type == TokenType.COMA) {
                        expect(TokenType.COMA)
                        continue
                    }
                    if (iterator.next().type == TokenType.DOT_COMA) break
                }
                TokenType.INTEGER, TokenType.FLOAT -> {
                }
                else -> {
                    errors.add("Error: Unexpected token '${currentToken.value}' in declaration")
                }
            }
            break
        }
    }

    fun parseVALORESDECLARACION() {
        parseVALORDECLARACION()
        if (iterator.hasNext() && iterator.next().type == TokenType.COMA) {
            parseVALORESDECLARACION()
        }
    }

    fun parseDECLARACION() {
        expect(TokenType.TYPE_INTEGER, TokenType.TYPE_FLOAT)
        parseVALORESDECLARACION()
    }

    fun parseASIGNACION() {
        expect(TokenType.DESIGNATOR)
        when (currentToken.type) {
            TokenType.INTEGER ->  expect(TokenType.INTEGER)
            TokenType.FLOAT -> expect(TokenType.FLOAT)
            else -> parseOPERACION()
        }
    }

    fun parseTEXTO() {
        currentToken = iterator.next()
            expect(TokenType.OPEN_PARENTHESES)
            expect(TokenType.IDENTIFIER)
            expect(TokenType.CLOSE_PARENTHESES)
    }

    fun parseINSTRUCCION() {
        when (currentToken.type) {
            TokenType.OP_READ, TokenType.OP_WRITE -> parseTEXTO()
            TokenType.IDENTIFIER -> {
                currentToken = iterator.next()
                if (currentToken.type == TokenType.DESIGNATOR) parseASIGNACION()
            }
            TokenType.TYPE_INTEGER, TokenType.TYPE_FLOAT -> parseDECLARACION()
            TokenType.OP_SUM, TokenType.OP_RES, TokenType.OP_MUL, TokenType.OP_DIV -> parseOPERACION()
            else -> {
                errors.add("Error: Unexpected token '${currentToken.value}'")
                return
            }
        }
        print("Hola")
        expect(TokenType.DOT_COMA)
    }

    fun parseCODIGO(){
        while (iterator.hasNext()) {
            when (currentToken.type) {
                TokenType.TYPE_INTEGER, TokenType.TYPE_FLOAT, TokenType.OP_READ, TokenType.OP_WRITE,
                TokenType.OP_SUM, TokenType.OP_RES, TokenType.OP_MUL, TokenType.OP_DIV,
                TokenType.IDENTIFIER -> parseINSTRUCCION()
                TokenType.CLOSE_CURLY_BRACE -> return
                else -> {
                    errors.add("Error: Unexpected token '${currentToken.value}'")
                    currentToken = iterator.next()
                }
            }
        }
    }

    fun parsePROGRAMA() {
        parseINICIO()
        parseCODIGO()
        parseFIN()
    }

    parsePROGRAMA()

    if (iterator.hasNext()) {
        errors.add("Error: Unexpected token '${iterator.next().value}'")
    }

    return errors
}
